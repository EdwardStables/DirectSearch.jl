var documenterSearchIndex = {"docs":
[{"location":"#DirectSearch.jl-1","page":"Home","title":"DirectSearch.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [DirectSearch]","category":"page"},{"location":"#DirectSearch.DefaultExtremeRef","page":"Home","title":"DirectSearch.DefaultExtremeRef","text":"DefaultExtremeRef\n\nThe collection index that refers to the default location of extreme barrier constraints.\n\n\n\n\n\n","category":"constant"},{"location":"#DirectSearch.DefaultProgressiveRef","page":"Home","title":"DirectSearch.DefaultProgressiveRef","text":"DefaultProgressiveRef\n\nThe collection index that refers to the default location of progressive barrier constraints.\n\n\n\n\n\n","category":"constant"},{"location":"#DirectSearch.DSProblem","page":"Home","title":"DirectSearch.DSProblem","text":"DSProblem{T}(N::Int; poll::AbstractPoll=LTMADS(N), search::AbstractSearch=NullSearch()) where T\n\nReturn a problem definition for an N dimensional problem. Specifiy the problem  configuration with poll and search. By default LTMADS is used for the poll step, with nothing used for the search step.\n\n\n\n\n\n","category":"type"},{"location":"#DirectSearch.LTMADS","page":"Home","title":"DirectSearch.LTMADS","text":"LTMADS{T}()\n\nReturn an empty LTMADS object. \n\n\n\n\n\n","category":"type"},{"location":"#DirectSearch.AddExtremeCollection-Union{Tuple{DirectSearch.Constraints{T}}, Tuple{T}} where T","page":"Home","title":"DirectSearch.AddExtremeCollection","text":"AddExtremeCollection(p::Constraints{T})::CollectionIndex where T\n\nInstantiate a new constraint collection for extreme constraints. Returns an index that  refers to the new collection.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.AddExtremeConstraint-Tuple{DirectSearch.Constraints,Array{Function,1}}","page":"Home","title":"DirectSearch.AddExtremeConstraint","text":"AddExtremeConstraint(p::AbstractProblem, c::Vector{Function})\n\nRegister a group of functions that define extreme barrier constraints. Return a vector of constraint indexes that refer to the constraints.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.AddExtremeConstraint-Union{Tuple{T}, Tuple{DirectSearch.Constraints{T},Function}} where T","page":"Home","title":"DirectSearch.AddExtremeConstraint","text":"AddExtremeConstraint(p::AbstractProblem, c::Function)::Tuple(ConstraintIndex, CollectionIndex)\n\nRegister a single function that defines an extreme barrier constraint. Return a constraint index.\n\nThe provided function should take a vector input and return a boolean value  indicating if the constraint has been met or not.\n\nThe index argument can be specified to give a collection to add the constraint to. The specified collection must exist, and must be able to accept extreme barrier constraints.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.AddProgressiveCollection-Union{Tuple{DirectSearch.Constraints{T}}, Tuple{T}} where T","page":"Home","title":"DirectSearch.AddProgressiveCollection","text":"AddProgressiveCollection(p::Constraints{T}; h_max=Inf, h_max_update::Function=h_max_update, \n                         aggregator::Function=x->max(0,x)^2)::CollectionIndex where T\n\nInstantiate a new constraint collection within the problem. Returns an index that refers to this new collection.\n\nThe default constraint settings match those from Audet & Dennis 2009:\n\nh_max: Begins as infinity\n\nh_max_update: Sets h_max to the largest valid h evaluation if an iteration is improving\n\naggregator: Creates h as ∑k(x) where k=max(0,x)^2\n\nNote that the aggregator differs from that proposed by Audet & Dennis 2009 due to supporting multiple values of h_max at the same time.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.AddProgressiveConstraint-Tuple{DirectSearch.Constraints,Array{Function,1}}","page":"Home","title":"DirectSearch.AddProgressiveConstraint","text":"AddProgressiveConstraint(p::AbstractProblem, c::Vector{Function})::Vector{Int}\n\nRegister a vector of functions that define a group of progressive barrier  constraints. Return a vector of indices that refer to the constriants.\n\nThe provided functions should take a vector input and return a violation amount. The return type should be the same as the type that the problem is defined as (default  is Float64).\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.AddProgressiveConstraint-Tuple{DirectSearch.Constraints,Function}","page":"Home","title":"DirectSearch.AddProgressiveConstraint","text":"AddProgressiveConstraint(p::AbstractProblem, c::Function)\n\nRegister a single function that defines a progressive barrier constraint. Return an index that refers to the constraint.\n\nThe provided function should take a vector input and return a violation amount. The return type should be the same as the type that the problem is defined as (default  is Float64).\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.Optimize!-Tuple{DSProblem}","page":"Home","title":"DirectSearch.Optimize!","text":"Optimize!(p::DSProblem)\n\nRun the direct search algorithm on problem p.\n\np must have had its initial point set, which must be valid for whatever constraints have been given.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.report-Tuple{DSProblem}","page":"Home","title":"DirectSearch.report","text":"report(p::DSProblem; save::Union{Bool,String}=false)\n\nPrints a summary of the problem to the console, or saves it as a text file.\n\nsave=true saves the report in the current REPL directory, but will error  if the default file name report is taken. Otherwise give a path as an argument to use that name.\n\nThe report contains the solver configuration, the initial and final incumbent points, the initial and final cost, the duration, the number of iterations, and the current status.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.AbstractMesh","page":"Home","title":"DirectSearch.AbstractMesh","text":"abstract type AbstractMesh end\n\nParent type of any struct implementing the construction of a mesh. To maintain  compatibility with other aspects of the package, the naming convention for  variables within structs must be followed. These respect the notation used  within Audet & Dennis 2006.\n\n\n\n\n\n","category":"type"},{"location":"#DirectSearch.AbstractPoll","page":"Home","title":"DirectSearch.AbstractPoll","text":"abstract type AbstractPollDirectionGenerator end\n\nParent type for any type used for implementing a direction generator.\n\nGenerally any direction generators should return vectors with unit length of one\n\n\n\n\n\n","category":"type"},{"location":"#DirectSearch.AbstractProgressiveConstraint","page":"Home","title":"DirectSearch.AbstractProgressiveConstraint","text":"AbstractProgressiveConstraint <: AbstractConstraint\n\nParent type for progressive contraints.\n\n\n\n\n\n","category":"type"},{"location":"#DirectSearch.CollectionIndex","page":"Home","title":"DirectSearch.CollectionIndex","text":"CollectionIndex\n\nAn Int wrapper that is used for indexing constraint collections within a Constraints object.\n\n\n\n\n\n","category":"type"},{"location":"#DirectSearch.ConstraintCollection","page":"Home","title":"DirectSearch.ConstraintCollection","text":"ConstraintCollection{T,C}(hmax::T, hmax_update::Function, aggregator::Function) where {T,C<:AbstractConstraint}\n\nContains multiple constraints of the same type that have the same settings applied to them.\n\nh_max is the initial hmax value. h_max_update is a function that should update h_max given an IterationOutcome value. aggregator is a function that will bring all constraint violations of a collection into a single h result.\n\nDefaults for each of these values is set in the AddProgressiveCollection and AddExtremeCollection functions.\n\n\n\n\n\n","category":"type"},{"location":"#DirectSearch.ConstraintIndex","page":"Home","title":"DirectSearch.ConstraintIndex","text":"CollectionIndex\n\nAn Int wrapper that is used for indexing constraints within a ConstraintCollection object.\n\n\n\n\n\n","category":"type"},{"location":"#DirectSearch.ConstraintOutcome","page":"Home","title":"DirectSearch.ConstraintOutcome","text":"@enum ConstraintOutcome\n\nHas the values Feasible, WeakInfeasible, or StrongInfeasible to classify the outcome of the  constraint evaluations of a point. A Feasible point meets the requirement of all constraints with no relaxation. A WeakInfeasible outcome requires one or more constraints to be relaxed, but less than their maximum amount. A StrongInfeasible outcome indicates one or more constraints was violated beyond its maximum relaxation amount.\n\n\n\n\n\n","category":"type"},{"location":"#DirectSearch.Constraints","page":"Home","title":"DirectSearch.Constraints","text":"Constraints{T}() where T\n\nCreate an object that constains multiple constraint collection objects.\n\nUpon creation Constraints is automativally populated with two constraint collections, an ExtremeCollection and a ProgressiveCollection.\n\n\n\n\n\n","category":"type"},{"location":"#DirectSearch.ExtremeConstraint","page":"Home","title":"DirectSearch.ExtremeConstraint","text":"ExtremeConstraint(f::Function)\n\nCreate an extreme barrier constraint. Function f should take a vector argument  and return true or false to indicate if the vector meets the constraint.\n\n\n\n\n\n","category":"type"},{"location":"#DirectSearch.IterationOutcome","page":"Home","title":"DirectSearch.IterationOutcome","text":"@enum IterationOutcome\n\nHas values Dominating, Improving, or Unsuccessful. Corresponding to the three iteration outcomes in progressive barrier direct search algorithms.\n\n\n\n\n\n","category":"type"},{"location":"#DirectSearch.ProgressiveConstraint","page":"Home","title":"DirectSearch.ProgressiveConstraint","text":"ProgressiveConstraint(f::Function)\n\nCreate a progressive barrier constraint. Function f should take a vector argument  and return a value in the range 0<=v<Inf to indicate the amount the constraint has been violated by the input vector. If input is a feasible point then the constraint  function should return zero. \n\n\n\n\n\n","category":"type"},{"location":"#DirectSearch.CacheFilter-Union{Tuple{T}, Tuple{DirectSearch.AbstractProblem{T},Any}} where T","page":"Home","title":"DirectSearch.CacheFilter","text":"CacheFilter(p::AbstractProblem{T}, points::Vector{T})::Tuple{Vector{Vector{T}},Vector{Vector{T}}} where T\n\nReturn a tuple where the first entry is the set of input points in the cache and the second is the set of input points not in the cache.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.CacheGet-Tuple{DirectSearch.AbstractProblem,Array{T,1} where T}","page":"Home","title":"DirectSearch.CacheGet","text":"CacheGet(p::AbstractProblem, x::Vector)\n\nReturn the cost of point x in the cache of p. Does not check if  x is in the cache, use CacheQuery to check.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.CacheGetRange-Tuple{DirectSearch.AbstractProblem,Array{T,1} where T}","page":"Home","title":"DirectSearch.CacheGetRange","text":"CacheGetRange(p::AbstractProblem, points::Vector)::Vector{Vector}\n\nReturn a vector of costs corresponding to the vector of points.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.CacheInitialPoint-Tuple{DirectSearch.AbstractProblem}","page":"Home","title":"DirectSearch.CacheInitialPoint","text":"CacheInitialPoint(p::AbstractProblem)\n\nReturn a tuple of the initial point added to the cache and its cost.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.CachePush-Tuple{DirectSearch.AbstractProblem,Array{T,1} where T,Any}","page":"Home","title":"DirectSearch.CachePush","text":"CachePush(p::AbstractProblem, x::Vector, cost)\n\nAdd point x and its cost cost to the cache of p. \n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.CacheQuery-Tuple{DirectSearch.AbstractProblem,Array{T,1} where T}","page":"Home","title":"DirectSearch.CacheQuery","text":"CacheQuery(p::AbstractProblem, x::Vector)\n\nQuery the cache of p to find if it has a cost value for point x. Alias  to haskey.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.CacheRandomSample-Tuple{DirectSearch.AbstractProblem,Int64}","page":"Home","title":"DirectSearch.CacheRandomSample","text":"CacheRandomSample(p::AbstractProblem, n::Int)\n\nReturns a uniformly sampled collection of n points from the cache. Points  can be repeated in the sample.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.CollectionTypeCount-Union{Tuple{T}, Tuple{DirectSearch.Constraints{T},DirectSearch.AbstractConstraint}} where T","page":"Home","title":"DirectSearch.CollectionTypeCount","text":"CollectionTypeCount(c::Constraints{T}, C::AbstractConstraint)::Int where T\n\nReturn the total number of constraints of type C that are stored in all collections.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.ConstraintCollectionEvaluation-Union{Tuple{T}, Tuple{DirectSearch.ConstraintCollection{T,DirectSearch.ExtremeConstraint},Array{T,1}}} where T","page":"Home","title":"DirectSearch.ConstraintCollectionEvaluation","text":"ConstraintCollectionEvaluation(collection::ConstraintCollection{T,ExtremeConstraint}, x::Vector{T})::ConstraintOutcome where T\n\nEvalute every constraint within extreme constraint collection collection for point x.\n\nIf any constraint returns false then a StrongInfeasible result is returned. Otherwise a  Feasible result is returned.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.ConstraintCollectionEvaluation-Union{Tuple{T}, Tuple{DirectSearch.ConstraintCollection{T,DirectSearch.ProgressiveConstraint},Array{T,1}}} where T","page":"Home","title":"DirectSearch.ConstraintCollectionEvaluation","text":"ConstraintCollectionEvaluation(collection::ConstraintCollection{T,ProgressiveConstraint}, x::Vector{T})::ConstraintOutcome where T\n\nEvalute every constraint within progressive constraint collection collection for point x.\n\nIf the aggregate value of the constraint evaluations exceeds h_max then a StrongInfeasible is  returned. If the value is 0.0 then Feasible is returned. Otherwise WeakInfeasible is returned.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.ConstraintEvaluation-Union{Tuple{T}, Tuple{DirectSearch.Constraints{T},Array{T,1}}} where T","page":"Home","title":"DirectSearch.ConstraintEvaluation","text":"ConstraintEvaluation(constraints::Constraints{T}, x::Vector{T})::Tuple{ConstraintOutcome,T} where T\n\nEvaluate point x over all constraint collections in constraints. Returns a  ConstraintOutcome indicating the result of the evaluation:\n\nFeasible: x evaluated as feasible for all constraints (extreme and progressive barrier)\n\nWeakInfeasible: x evaluated as feasible for all extreme barrier constraints, and had no  progressive barrier constraint violations greater than h_max\n\nStrongInfeasible: At least one extreme barrier constraint evaluated as infeasible, or at least one progressive barrier constraint had a violation greater than h_max\n\nThe second returned value is the sum of h_max values evaluated during the constraint checks.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.ConstraintUpdate!-Tuple{DirectSearch.Constraints,DirectSearch.IterationOutcome}","page":"Home","title":"DirectSearch.ConstraintUpdate!","text":"ConstraintUpdate!(c::Constraints, result::IterationOutcome)\n\nPerform all necessary actions required to update a problem's constraints between iterations. \n\nCurrently will call h_max_update on each constraint.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.EvaluatePoint!-Union{Tuple{T}, Tuple{DSProblem{T},Any}} where T","page":"Home","title":"DirectSearch.EvaluatePoint!","text":"EvaluatePoint!(p::DSProblem{T}, trial_points)::IterationOutcome where T\n\nDetermine whether the set of trial points result in a dominating, improving, or unsuccesful algorithm iteration. Update the feasible and infeasible incumbent points of p.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.GenerateDirections-Tuple{DirectSearch.AbstractProblem,LTMADS}","page":"Home","title":"DirectSearch.GenerateDirections","text":"GenerateDirections(p::DSProblem, DG::LTMADS; maximal_basis=false)\n\nGenerates columns and forms a basis matrix for direction generation. \n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.GenerateSearchPoints-Tuple{DSProblem,NullSearch}","page":"Home","title":"DirectSearch.GenerateSearchPoints","text":"GenerateSearchPoints(p::DSProblem)\n\nSearch method that returns an empty vector.\n\nUse when no search method is desired.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.GenerateSearchPoints-Tuple{DSProblem}","page":"Home","title":"DirectSearch.GenerateSearchPoints","text":"GenerateSearchPoints(p::DSProblem{T})::Vector{Vector{T}} where T\n\nAlias for GenerateSearchPoints(p, NullSearch).\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.GenerateSearchPoints-Union{Tuple{T}, Tuple{DSProblem{T},RandomSearch}} where T","page":"Home","title":"DirectSearch.GenerateSearchPoints","text":"GenerateSearchPoints(p::DSProblem{T}, ::RandomSearch)::Vector{Vector{T}} where T\n\nFinds points that are Δᵐ distance from any point in the mesh in a uniformly random direction.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.GetHmaxSum-Tuple{DirectSearch.Constraints}","page":"Home","title":"DirectSearch.GetHmaxSum","text":"GetHmaxSum(c::Constraints)\n\nReturn the sum of all h_max values for each collection in c.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.MeshUpdate!-Union{Tuple{T}, Tuple{DirectSearch.Mesh{T},LTMADS{T},DirectSearch.IterationOutcome}} where T","page":"Home","title":"DirectSearch.MeshUpdate!","text":"MeshUpdate!(mesh::Mesh, improvement_found::Bool)\n\nImplements LTMADS update rule from Audet & Dennis 2006 pg. 203 adapted for progressive  barrier constraints with Audet & Dennis 2009 expression 2.4\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.SetMaxEvals-Tuple{DSProblem,Int64}","page":"Home","title":"DirectSearch.SetMaxEvals","text":"SetMaxEvals(p::DSProblem, m::Int)\n\nSet the maximum number of simultanious function evaluations that can be run. By default this will be set 1.\n\nIf the function evaluation is not overriden (e.g. for sending calculation to a cluster) then setting this to a number greater than your PC's number of threads will result  in no improvement.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.export_points-Tuple{DSProblem}","page":"Home","title":"DirectSearch.export_points","text":"export_points(p::DSProblem)\n\nGives the trace of considered points during optimisation. Note that this is unavailable if tracking of points has been disabled \n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.function_evaluation-Union{Tuple{T}, Tuple{DSProblem{T},Array{Array{T,1},1}}} where T","page":"Home","title":"DirectSearch.function_evaluation","text":"function_evaluation(p::DSProblem{T}, trial_points::Vector{Vector{T}})::Vector{T} where T\n\nCalculate the cost of the points in trial_points and return as a vector. \n\nIf the number of available workers is greater than one, and the maxsimultaniousevaluations value of p is greater than one then the calculation is distributed across  several cores. \n\nCurrently, this has significant overheads and is much slower than evaluating in a single threaded manner on all testcases. This may give performance benefits when f is a heavy, single threaded operation.\n\nIf a specialised way  of calling the function is needed then this function should be overriden, e.g.: \n\nfunction DS.function_evaluation(p::DS.DSProblem{T}, trial_points::Vector{Vector{T}}) where T\n\tprintln(\"I am overriden\")\t\n\treturn map(p.objective, trial_points)\nend\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.function_evaluation-Union{Tuple{T}, Tuple{DSProblem{T},Array{T,1}}} where T","page":"Home","title":"DirectSearch.function_evaluation","text":"function_evaluation(p::DSProblem{T}, trial_point::Vector{T})::T where T\n\nEvaluate a single trial point with the objective function of p. \n\nBy default calls the function with the trial point and returns the result. Override to  provide custom evaluation behaviour.\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.h_max_update-Tuple{DirectSearch.ConstraintCollection,DirectSearch.IterationOutcome}","page":"Home","title":"DirectSearch.h_max_update","text":"h_max_update(c::ConstraintCollection, result::IterationOutcome)\n\nUpdate h_max according to the LTMADS default in eqn 2.5, Audet & Dennis 2009\n\n\n\n\n\n","category":"method"},{"location":"#DirectSearch.report_finish-Tuple{DSProblem}","page":"Home","title":"DirectSearch.report_finish","text":"report_finish(p::DSProblem)\n\nIf not silent, give a short printout of the result of the problem.\n\nStates the duration, final point, final cost, and reason for stopping. A more detailed report can be shown with report.\n\n\n\n\n\n","category":"method"}]
}
